workflow:
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH

stages: [build, fe, be, test, quality, sast, gate]

include:
  - template: Code-Quality.gitlab-ci.yml
  - template: Security/SAST.gitlab-ci.yml
  - template: Security/Dependency-Scanning.gitlab-ci.yml
  - template: Security/Container-Scanning.gitlab-ci.yml

variables:
  NODE_OPTIONS: --max-old-space-size=2048
  PIP_CACHE_DIR: "$CI_PROJECT_DIR/.cache/pip"
  NPM_CONFIG_CACHE: "$CI_PROJECT_DIR/.cache/npm"

  # Stage-urile securitate
  SAST_STAGE: "sast"
  DS_STAGE: "sast"
  CS_STAGE: "sast"

  # Praguri (poți seta în Settings→CI/CD→Variables)
  NPM_AUDIT_LEVEL: "critical"
  MIN_COVERAGE: "60"
  QUALITY_MAX_ISSUES: "0"
  SEC_MAX_CRITICAL: "0"
  SEC_MAX_HIGH: "0"
  SEC_MAX_MEDIUM: "999"

# ---------- BUILD IMAGE pt Container Scanning (opțional) ----------
build_image:
  stage: build
  image: docker:25
  services: [ docker:25-dind ]
  variables:
    DOCKER_TLS_CERTDIR: "/certs"
    DOCKER_DRIVER: overlay2
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
      exists: [ "Dockerfile" ]
  script:
    - echo "$CI_REGISTRY_PASSWORD" | docker login -u "$CI_REGISTRY_USER" "$CI_REGISTRY" --password-stdin
    - docker build -t "$CI_REGISTRY_IMAGE:$CI_COMMIT_SHA" .
    - docker push "$CI_REGISTRY_IMAGE:$CI_COMMIT_SHA"
  artifacts:
    when: always
    expire_in: 1 week

.container_scanning:
  variables:
    CS_IMAGE: "$CI_REGISTRY_IMAGE:$CI_COMMIT_SHA"

# ---------- FRONTEND ----------
frontend:
  stage: fe
  image: node:20
  cache: { key: "${CI_COMMIT_REF_SLUG}-fe", paths: [ .cache/npm/ ] }
  before_script:
    - cd frontend
    - |
      if [ -f yarn.lock ]; then
        corepack enable
        yarn --version
        yarn install --immutable
      else
        npm ci
      fi
  script:
    - |
      if [ -f yarn.lock ]; then
        yarn run lint
        if grep -q '"build"' package.json; then yarn build; fi
        yarn audit --level "${NPM_AUDIT_LEVEL}"
        if jq -e '.scripts.test' package.json >/dev/null 2>&1 || grep -qi jest package.json; then
          yarn test --coverage --coverageReporters=cobertura --coverageReporters=html || true
        fi
      else
        npm run lint
        npm run build --if-present
        npm audit --audit-level="${NPM_AUDIT_LEVEL}"
        if jq -e '.scripts.test' package.json >/dev/null 2>&1 || grep -qi jest package.json; then
          npm run -s test -- --ci --coverage --coverageReporters=cobertura --coverageReporters=html || true
        fi
      fi
  artifacts:
    when: always
    expire_in: 1 week
    paths:
      - frontend/build/
      - frontend/coverage/
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH

# ---------- BACKEND ----------
backend:
  stage: be
  image: python:3.11
  cache: { key: "${CI_COMMIT_REF_SLUG}-be", paths: [ .cache/pip/ ] }
  before_script:
    - cd backend
    - pip install -U pip
    - pip install ruff mypy bandit pytest pip-audit pytest-cov coverage flake8 flake8-html
    - |
      if [ -f requirements.txt ]; then
        pip install -r requirements.txt
      fi
    - mkdir -p reports/flake8 reports/bandit reports/mypy reports/coverage_html
  script:
    - ruff --output-format=github check .
    - ruff format --check
    - mypy . --ignore-missing-imports --pretty
    - bandit -ll -r . -x tests
    - |
      if [ -f requirements.txt ]; then
        pip-audit -r requirements.txt --strict
      else
        pip-audit --strict
      fi
    - pytest -q --maxfail=1 --disable-warnings --cov=. --cov-report=xml:coverage.xml --cov-report=html:reports/coverage_html || true
    - flake8 . --format=html --htmldir reports/flake8 || true
    - bandit -r . -f html -o reports/bandit/index.html || true
    - mypy . --ignore-missing-imports --html-report reports/mypy || true
  artifacts:
    when: always
    expire_in: 1 week
    reports:
      coverage_report:
        coverage_format: cobertura
        path: backend/coverage.xml
    paths:
      - backend/reports/flake8/
      - backend/reports/bandit/
      - backend/reports/mypy/
      - backend/reports/coverage_html/
      - backend/.ruff_cache/
      - backend/.mypy_cache/
      - backend/coverage.xml
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH

# ---------- COVERAGE GATE ----------
coverage-gate:
  stage: test
  image: python:3.11
  needs: [backend]
  script:
    - |
      python - <<'PY'
      import os, sys, xml.etree.ElementTree as ET
      p="backend/coverage.xml"
      if not os.path.exists(p):
          print("NO_COVERAGE_XML -> SKIP (green)"); sys.exit(0)
      root=ET.parse(p).getroot()
      total=int(root.attrib.get("lines-valid","0") or 0)
      covd=int(root.attrib.get("lines-covered","0") or 0)
      cov=0.0 if total==0 else 100.0*covd/total
      MIN=float(os.getenv("MIN_COVERAGE","60"))
      print(f"COVERAGE={cov:.2f}%  (MIN={MIN}%)")
      sys.exit(0 if cov>=MIN else 1)
      PY
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"

# ---------- CODE QUALITY GATE ----------
quality-gate:
  stage: quality
  image: alpine:3.19
  needs: [code_quality]
  dependencies: [code_quality]
  script:
    - apk add --no-cache jq >/dev/null
    - FILE="gl-code-quality-report.json"
    - |
      if [ ! -f "$FILE" ]; then
        echo "WARN: lipsește $FILE (Code Quality). Trecem cu verde."
        exit 0
      fi
    - COUNT=$(jq 'length' "$FILE")
    - echo "Code Quality issues: $COUNT"
    - MAX=${QUALITY_MAX_ISSUES:-0}
    - if [ "$COUNT" -le "$MAX" ]; then echo "OK: $COUNT <= $MAX"; else echo "FAIL: $COUNT > $MAX"; exit 1; fi
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"

# ---------- SECURITY GATE (SAST + Dependency Scan) ----------
security-gate:
  stage: gate
  image: alpine:3.19
  needs: [sast, dependency_scanning]
  dependencies: [sast, dependency_scanning]
  script:
    - apk add --no-cache jq >/dev/null
    - |
      files=("gl-sast-report.json" "gl-dependency-scanning-report.json")
      crit=0; high=0; med=0
      for f in "${files[@]}"; do
        if [ -f "$f" ]; then
          c=$(jq '[.vulnerabilities[]? | select(.severity=="Critical")] | length' "$f"); crit=$((crit+c))
          h=$(jq '[.vulnerabilities[]? | select(.severity=="High")] | length' "$f");     high=$((high+h))
          m=$(jq '[.vulnerabilities[]? | select(.severity=="Medium")] | length' "$f");   med=$((med+m))
          echo "$f -> Critical=$c High=$h Medium=$m"
        else
          echo "INFO: $f nu există (job probabil sărit)."
        fi
      done
      echo "TOTAL -> Critical=$crit High=$high Medium=$med"
      MAXC=${SEC_MAX_CRITICAL:-0}; MAXH=${SEC_MAX_HIGH:-0}; MAXM=${SEC_MAX_MEDIUM:-999}
      [ "$crit" -le "$MAXC" ] || { echo "FAIL: Critical $crit > $MAXC"; exit 1; }
      [ "$high" -le "$MAXH" ] || { echo "FAIL: High $high > $MAXH"; exit 1; }
      [ "$med"  -le "$MAXM" ] || { echo "FAIL: Medium $med > $MAXM"; exit 1; }
      echo "Security gate PASSED ✅"
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"

# ---------- FINAL GATE ----------
gate:
  stage: gate
  image: alpine:3.19
  needs: [frontend, backend, coverage-gate, quality-gate, security-gate]
  script: [ 'echo "All enterprise gates passed ✅"' ]
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"